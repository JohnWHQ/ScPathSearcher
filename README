###########################################################
READ ME DOC
###########################################################

路径连通性判断算法

@author John 
@date 2022/3

@env python2.7

###########################################################

描述：
	判断一个规格为n*m矩阵,左边到右边是否有联通量 
		连通   算法返回True并支持图形分析生成
		不连通 算法返回False并支持图形分析生成


###########################################################

结构：

-PathSearch      工程目录
	--pic	        算法分析图Demo
	--tmp	        算法分析图生成目录
	main.py          执行demo入口
	node.py          结点实体类
	path_search.py   算法主体类
	image_utils.py   算法分析图像工具类

###########################################################

调用:

	desc:

	# 1.构建一个n*m的二位矩阵, 当前支持二值 0:不可达 1:可达,main中生成函数支持按a/b概率去moc生成装为1的矩阵
	matrix = build_matrix(n, m, a, b)
	# 2.初始化算法实体类,将要计算的矩阵matrix配置进对象
	searcher = PathSearcher(matrix)
	# 3.算法触发 generate_image参数控制是否需要保持算法分析图像(建议最大size:100*100,视机器性能而定)
	searcher.run(generate_image=False)

	eg:
		matrix = build_matrix(5000, 5000, 10, 100)
		searcher = PathSearcher(matrix)
		searcher.run(generate_image=image_flag)

	python main.py


算法：

	当前算法采用优化后的BFS算法

	时间复杂度: <= O(n * m^2)

		O(m) * O(n*m)

		O(m)
			代表左边起始有效结点
		O(n*m) 
			算法使用双端队列,迭代过程中使用Set去重已经遍历过的结点，由于最差case会遍历全部结点n*m个
			且每个结点最多只能遍历到1次(进入双端队列一次)

		综上整体计算会对左侧m个结点依次遍历O(m),然后触发BFS处理最多O(n*m)次 = O(n * m^2)


	空间复杂度: = O(n * m)

		算法输入是一个二维矩阵则需要n*m的空间,双端队列最大为8即邻域O(max(x邻域)),左边(行)set需要最大O(m)的存储空间
		综上整体计算== O(n * m)



坐标系：

	0,0为原点 n轴向下递增为行 m轴向右递增为列

	   0------------------------------------>m
	   |
	   |
	   |
	   |
	   |
	   |
	   |
	   |
	   |
	   |
	   |
	   V
	   n



分析：

	A* Dijkstra Floyd BFS DFS 对比



优化：



